from app import app
from app.api import blueprint
from app.home.utils import Utils, Misc

from app.api.utils import token_required
from flask import jsonify
from flask_restx import Api, Resource, reqparse, inputs, Namespace
from werkzeug.datastructures import FileStorage
from werkzeug.utils import secure_filename
import glob
import os
import random
import string

from wtforms.validators import Regexp
from wtforms.fields import StringField

import datetime
from flask_restx import fields

from app.home.models import Group, Project, Run, Process

## Token
authorizations = {
    'apikey': {
        'type': 'apiKey',
        'in': 'header',
        'name': 'X-API-KEY'
    }
}

## Create the API
desc  = "This is a RESTful API to interact with Nextpie web application.\n"
desc += "Code repository: https://github.com/bishwaG/Nextpie\n"
desc += "Contact: nextpietool@gmail.com"
ver   = "1.0"
api = Api(blueprint,
          version=ver,
          title="Nextpie API entry point",
          description=desc,
          doc="/api/v"+ver,
          prefix="/api/v"+ver,
          authorizations=authorizations)

ns1 = Namespace('default', description='Default namespace')
#api.add_namespace(ns1,path="/api/upload-data")
#api.add_namespace(ns1,path="/api/get-runs")


## for select list
years = [(year, str(year)) for year in range(2020, datetime.datetime.now().year + 1)]

################################################################################
## U P L O A D   D A T A
################################################################################

## Input fields File, Workflow, Version, Group, Project
parser = api.parser()
parser.add_argument('File', location='files',type=FileStorage, required=True,
                            help="Trace.txt produced from Nextflow")
parser.add_argument('Workflow', type=str, required=True, help='Workflow name.', trim=True)
parser.add_argument('Version',  type=str, required=True, help='Workflow version. Example: 1.0.2', trim=True)
parser.add_argument('Group',    type=str, required=True, help='Research group name.', trim=True)
parser.add_argument('Project',  type=str, required=True, help='Project name.', trim=True)


## Upload data
@api.route('/upload-data', endpoint='upload-data')
@api.doc(security='apikey')
class MyResource1(Resource):

	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@api.expect(parser)
	@token_required
	
	
	def post(self):
		"Upload trace file generated by Nextlow."
		args = parser.parse_args()

		trace_file = args['File']
		filename   = secure_filename(trace_file.filename)
		
		#if not (filename == "Trace.txt" or filename == "trace.txt"):
		#	return {"message":"File name can only be Trace.txt or trace.txt "},422
		
		if not filename.endswith(".txt"):
			return {"message":"File name can only have .txt extension."},422
		
		
		
		workflow   = args['Workflow']
		version    = args['Version']
		group      = args['Group']
		project    = args['Project']
		
		print("[apps.api.routes ] WORKFLOW: " + workflow + 
		                   "\tVERSION:  " + version  +
		                   "\tGROUP  :  " + group +
		                   "\tPROJECT:  " + project+
		                   "\tFILE: "+ filename)
		
		## replace / by _ if any exists
		workflow = workflow.replace("/", "_")
		workflow = workflow.replace(" ", "_")
		version  = version.replace("/", "_")
		version  = version.replace(" ", "_")
		
		## if group and project empty generate randomly.
		rnd_group_proj = False
		if not group or not project or group=="null" or project=="null":
			group         = Misc.gen_groupName()
			project       = Misc.gen_projectName()
			rnd_group_proj    = True
		
		details = [group, project, workflow, version]
		#return jsonify(details)
		
		## get uploaded file
		upload_path = os.path.join( app.config['UPLOAD_FOLDER'], "API")
		
		## create upload dir -------------------------------------------
		#if not os.path.isdir(path):
		#	os.makedirs(path, exist_ok=True)
		
		
		try:
			if not os.path.isdir(upload_path):
				os.makedirs(upload_path, exist_ok=True)
		except PermissionError as e:
			return jsonify({"message": f"Permission denied: {e}", "response": "error"})
		except Exception as e:
			return jsonify({"message": f"An error occurred: {e}", "response": "error"})
		
		
		## Save uploaded file by ---------------------------------------
		## adding random sting at the back.
		# Generate a random string of 10 characters
		random_string = ''.join(random.choices(string.ascii_letters + string.digits, k=20))
		# Split the filename into base name and extension
		base_name, extension = filename.rsplit('.', 1)
		# Create the new filename
		new_filename = f"{base_name}_{random_string}.{extension}"
		
		if trace_file:
			try:
				# Save the file to the specified upload_path
				trace_file.save(os.path.join(upload_path, new_filename))
			except PermissionError as e:
				# Handle permission-related errors (e.g., no write access)
				return jsonify({"message": f"Permission denied: {e}", "response": "error"})
			except FileNotFoundError as e:
				# Handle errors if the directory is not found
				return jsonify({"message": f"File not found: {e}", "response": "error"})
			except Exception as e:
				# Handle any other unexpected errors
				return jsonify({"message": f"An error occurred: {e}", "response": "error"})
		
		## check if the file is empty
		file_path = os.path.join(upload_path, new_filename)
		if os.path.getsize(file_path) == 0:
			return jsonify({"message": f"The trace file {file_path} is empty.", "response": "error"})
		
		
		## check the trace file has required columns
		required_headers = ['task_id', 'hash', 'native_id', 'name', 
		'status', 'exit', 'submit',     'duration', 'realtime', 
		'%cpu', 'peak_rss', 'peak_vmem', 'rchar', 'wchar']
		
		with open(file_path, 'r') as f:
			header_line = f.readline().strip()
		columns = header_line.split('\t')
		missing = [col for col in required_headers if col not in columns]
		
		if missing:
			return jsonify(  {"message":f"Missing columns: {missing} in the trace file.", "response":"error"} )

				
		x =  Utils.parseTraceFiles(details, file_path, actionSource="API", random_group_proj=rnd_group_proj )
		
		
		## delete uploded file
		"""
		if os.path.exists(file_path):
			os.remove(file_path)
			print(f"Trace file '{file_path}' deleted.")
		else:
			print(f"Trace file '{file_path}' does not exist.")
		"""
		return jsonify(x)
		#api.abort(403)


################################################################################
## G E T   G R O U P S  &  P R O J E C T S 
################################################################################
from app.api.analysis import Analysis
@api.route('/get-groups', endpoint='get-groups')
@api.doc(security='apikey')
class GetGroups(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@token_required
	def get(self):
		return Analysis.get_all_groups()
	


@api.route('/get-projects', endpoint='get-projects')
@api.doc(security='apikey')
class GetProjects(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	#@token_required
	def get(self):
		return Analysis.get_all_projects()		

################################################################################
## G E T   R U N S
################################################################################

## input fields 
parser2 = api.parser()
#parser2.add_argument('Year',type=str, required=True, help="Year", choices=tuple(range(2015, 2050,1)))
parser2.add_argument('Year', type=int, required=False, help="Select a year", choices=[year[0] for year in years])


@api.route('/get-runs', endpoint='get-runs')
@api.doc(security='apikey')
class GetRuns(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@api.expect(parser2)
	#@token_required
	def post(self):
		args = parser2.parse_args()
		year = args['Year']
		return Analysis.get_runs(year)
		
		
################################################################################
## G E T   P R O C E S S E S
################################################################################


## input fields 
parser3 = api.parser()
parser3.add_argument('Year', type=int, required=False, help="Select a year", choices=[year[0] for year in years])
parser3.add_argument('Project', type=str, required=False, help="Project name")
parser3.add_argument('Status', type=str, required=False, 
                     help="Process status", 
                     choices=("","COMPLETED", "FAILED", "CACHED", "ABORTED"))

@api.route('/get-processes', endpoint='get-processes')
@api.doc(security='apikey')
class GetProcs(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@api.expect(parser3)
	#@token_required
	def post(self):
	
		args    = parser3.parse_args()
		year    = args["Year"]
		project = args["Project"]
		status  = args["Status"]
		
		return jsonify([{"message":"Not implemented!"}])


################################################################################
## G E T   D A T A   F O O T P R I N T
################################################################################

## by year
parser4 = api.parser()

@api.route('/get-data-footprint-yearly-TB', endpoint='get-data-footprint-yearly-TB')
@api.doc(security='apikey')
class GetFootprintYr(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@api.expect(parser4)
	#@token_required
	def get(self):
		return Analysis.get_footprint_by_year()
                  

parser5 = api.parser()
parser5.add_argument('Year', type=int, required=True, help="Select a year", choices=[year[0] for year in years])

@api.route('/get-data-footprint-montly-TB', endpoint='get-data-footprint-montly-TB')
@api.doc(security='apikey')
class GetFootprintMth(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@api.expect(parser5)
	#@token_required
	def post(self):
		args = parser5.parse_args()
		year = args['Year']
		return Analysis.get_footprint_by_month(year)




################################################################################
## G E T   T O T A L (Groups, projects, runs, processe)
################################################################################
parser6 = api.parser()

@api.route('/get-total', endpoint='get-total')
@api.doc(security='apikey')
class GetTotal(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@api.expect(parser6)
	#@token_required
	def get(self):
		
		groups    = Group.query.count()
		projects  = Project.query.count()
		runs      = Run.query.count()
		processes = Process.query.count()

		return jsonify([{"groups": groups,
		                "projects": projects,
		                "runs": runs,
		                "processes": processes}])


################################################################################
## W O R K F L O W S   B Y   S T A T U S
################################################################################
parser7 = api.parser()

@api.route('/get-workflows-no-by-status', endpoint='get-workflow-by-status')
@api.doc(security='apikey')
class GetWorkflowByStatus(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@api.expect(parser7)
	#@token_required
	def get(self):
		
		pass



################################################################################
## CLEAR TEST DATA
################################################################################
def comma_separated_numbers(value):
	"""
	Validates that the input is either a number or comma-separated numbers.
	Returns the cleaned list of integers.
	"""
	try:
		# split by comma
		parts = value.split(',')
		# convert all to integers to validate
		return [int(p.strip()) for p in parts if p.strip()]
	except ValueError:
		raise ValueError("Group IDs must be a number or comma-separated numbers (e.g., 1 or 1,2,3)")


parser8 = api.parser()
parser8.add_argument('Group IDs', type=comma_separated_numbers, required=True, help="Group IDs separated by commas")

                     
@api.route('/delete-records', endpoint='delete-records')
@api.doc(security='apikey')
class ClearDB(Resource):
	@ns1.doc(responses={403: 'Not Authorized', 200:'Success'})
	@api.expect(parser8)
	#@token_required
	def post(self):
		
		"Remove the group records from the database."
		
		
		args          = parser8.parse_args()
		input_gids    = args["Group IDs"]
		
		deleted_ids = list()
		deleted_groups = list()
		
		for gid in input_gids:
			if gid != "":
				group      = Group.query.get(int(gid))
				if group:
					db.session.delete(group)
					db.session.commit()
					deleted_ids.append( str(gid) )
					deleted_groups.append( group.name )
		
		return jsonify([{"deleted_group_id": deleted_ids,
		                 "deleted_group_name": deleted_groups}])




































